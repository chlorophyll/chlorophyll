<html>
	<head>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			#parent {
				display: flex;
			}
			#container {
				width: 100%;
				height: 100%;
			}
		</style>
	</head>
	<body>
		<div id="parent">
			<div id="container"></div>
		</div>
		<script src="icosahedron.js"></script>
		<script src="js/model.js"></script>
		<script src="js/marquee.js"></script>
		<script src="three/build/three.js"></script>
		<script src="three/js/controls/OrbitControls.js"></script>
		<script src="three/js/renderers/Projector.js"></script>
		<script src="three/js/libs/stats.min.js"></script>
		<script>
var container, stats;
var camera, scene, controls, renderer, particles, group, geometry, i, h, color, sprite, size;
var model;
var mouseX = 0, mouseY = 0;
var width, height;
var colors;
var positions;
var selected = {};
init();
animate();

function screenCoords(position) {
	var vector = position.clone();
	var canvas = renderer.domElement;

	// map to normalized device coordinate (NDC) space
	vector.project( camera );

	vector.x = Math.round( (   vector.x + 1 ) * canvas.width  / 4 );
	vector.y = Math.round( ( - vector.y + 1 ) * canvas.height / 4 );

	vector.z = 0;
	return vector;
}

function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.lineTo(x+w-r, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+r);
    ctx.lineTo(x+w, y+h-r);
    ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
    ctx.lineTo(x+r, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-r);
    ctx.lineTo(x, y+r);
    ctx.quadraticCurveTo(x, y, x+r, y);
    ctx.closePath();
    ctx.fill();
	ctx.stroke();
}

// This place is not a place of honor.
// No highly esteemed deed is commemorated here.
// Nothing valued is here. What is here is repulsive to us. 
// It came from StackOverflow.
function textSprite(message, parameters) {
	if ( parameters === undefined ) parameters = {};
	var fontface = parameters.hasOwnProperty("fontface") ? parameters["fontface"] : "Arial";
	var fontsize = parameters.hasOwnProperty("fontsize") ? parameters["fontsize"] : 18;
	//fontsize *= 4;
	var borderThickness = parameters.hasOwnProperty("borderThickness") ? parameters["borderThickness"] : 4;
	var borderColor = parameters.hasOwnProperty("borderColor") ?parameters["borderColor"] : { r:0, g:0, b:0, a:1.0 };
	var backgroundColor = parameters.hasOwnProperty("backgroundColor") ?parameters["backgroundColor"] : { r:255, g:255, b:255, a:1.0 };
	var textColor = parameters.hasOwnProperty("textColor") ?parameters["textColor"] : { r:0, g:0, b:0, a:1.0 };

	var canvas = document.createElement('canvas');
	var context = canvas.getContext('2d');
	context.font = "Bold " + fontsize + "px " + fontface;
	var metrics = context.measureText( message );
	var textWidth = metrics.width;
	var width = (textWidth + borderThickness);
	var height = fontsize * 1.4 + borderThickness;

	canvas.width = width;
	canvas.height = height;
	context.font = "Bold " + fontsize + "px " + fontface;

	context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + "," + backgroundColor.b + "," + backgroundColor.a + ")";
	context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + "," + borderColor.b + "," + borderColor.a + ")";

	context.lineWidth = borderThickness;
	roundRect(context, borderThickness/2, borderThickness/2, width, height, 8);

	context.fillStyle = "rgba("+textColor.r+", "+textColor.g+", "+textColor.b+", 1.0)";
	context.fillText( message, borderThickness, fontsize + borderThickness);

	var texture = new THREE.Texture(canvas);
	texture.minFilter = THREE.LinearFilter; // NearestFilter;
	texture.needsUpdate = true;

	var spriteMaterial = new THREE.SpriteMaterial( { map: texture} );
	var sprite = new THREE.Sprite( spriteMaterial );
	sprite.scale.set(fontsize, fontsize / 2, 0.1 * fontsize);
	return sprite;
}
function init() {
	container = document.getElementById('container');
	width = container.clientWidth;
	height = container.clientHeight;
	//
	camera = new THREE.PerspectiveCamera(55, width/height, 2, 2000 );
	camera.position.z = 1000;

	scene = new THREE.Scene();
	//scene.fog = new THREE.FogExp2(0x000000, 0.0003);
	scene.fog = new THREE.Fog(0x000000, 750, 2000);
	//
	geometry = new THREE.BufferGeometry();

	positions = new Float32Array(900 * 3);
	colors = new Float32Array(900 * 3);
	var color = new THREE.Color();
	var strip_colors = [
		[  0,   1,   0],
		[0.5,   0,   1],
		[  1,   0,   0],
		[  1, 0.5,   0],
		[  1,   1,   0]
	]
	var i = 0;

	model = new Model(geometry);
	model.loadData(icosahedron_data);
	particles = model.makeMesh();
	scene.add(particles);

	renderer = new THREE.WebGLRenderer({ antialias: false });
	renderer.setClearColor(scene.fog.color);
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(width, height);
	container.appendChild(renderer.domElement);

	controls = new THREE.OrbitControls(camera, renderer.domElement);
	controls.enableDamping = true;
	controls.dampingFactor = 0.75;
	controls.enableZoom = true;

	marquee = new Marquee(controls);
	container.appendChild(marquee.dom);

	stats = new Stats();
	container.appendChild(stats.dom);

	document.addEventListener('marquee-move', onMarqueeMove, false);
	document.addEventListener( "mousedown", onDocumentMouseDown);
	window.addEventListener('resize', onWindowResize, false);
}

function onMarqueeMove(event) {
	var l = Math.min(event.detail.startX, event.detail.endX);
	var r = Math.max(event.detail.startX, event.detail.endX);
	var t = Math.min(event.detail.startY, event.detail.endY);
	var b = Math.max(event.detail.startY, event.detail.endY);
	console.log(l,r,t,b);

	var c = new THREE.Color(1, 1, 1);

	model.forEachStrip(function(strip, i) {
		var v = model.getPosition(i);
		var s = screenCoords(v);

		if (i < 5) {
			console.log(s);
		}

		if (s.x >= l && s.x <= r && s.y >= t && s.y <= b) {
			model.setColor(i, c);
		}
	});
}

function onWindowResize() {
	camera.aspect = container.clientWidth / container.clientHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(container.clientWidth, container.clientHeight);
}

function onDocumentMouseDown( event ) {
       var mouse3D = new THREE.Vector3(
                       (event.clientX / window.innerWidth) * 2 - 1,
                       -(event.clientY / window.innerHeight) * 2 + 1,
                       0.5);
       var projector = new THREE.Projector();
       var raycaster = new THREE.Raycaster();
       raycaster.params.Points.threshold = 5;
       raycaster.setFromCamera(mouse3D, camera);
       var intersects = raycaster.intersectObject(particles);

       if (intersects.length == 0) return;
       console.log(event.clientX, event.clientY);
	   console.log(screenCoords(intersects[0].point));
}

function animate() {
	requestAnimationFrame(animate);
	render();
	stats.update();
	controls.update();
}

function render() {
	renderer.render(scene, camera);
}
		</script>
	</body>
</html>
