<html>
	<head>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<div id="container"></div>
		<script src="build/three.js"></script>
		<script src="model.js"></script>
		<script src="js/renderers/Projector.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script>
var container, stats;
var camera, scene, renderer, particles, geometry, material, i, h, color, sprite, size;
var mouseX = 0, mouseY = 0;
var windowHalfX = window.innerWidth / 2;
var windowHalfY = window.innerHeight / 2;
var colors;
var positions;
var selected = {};
init();
animate();
function init() {
	container = document.getElementById('container');
	//
	camera = new THREE.PerspectiveCamera( 55, window.innerWidth / window.innerHeight, 2, 2000 );
	camera.position.z = 1000;
	scene = new THREE.Scene();
	scene.fog = new THREE.FogExp2(0x000000, 0.0008);
	//
	geometry = new THREE.BufferGeometry();
	positions = new Float32Array(icosahedron.length * 3);
	colors = new Float32Array(icosahedron.length * 3);
	var color = new THREE.Color();

	for (var i = 0; i < icosahedron.length; i++) {
		for (var j = 0; j < 3; j++) {
			positions[3*i + j] = icosahedron[i][j];
		}
		colors[3*i+0] = 255;
		colors[3*i+1] = 0;
		colors[3*i+2] = 0;
	}
	geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
	geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3).setDynamic(true));
	geometry.computeBoundingSphere();
	//
	var material = new THREE.PointsMaterial({ size: 10, vertexColors: THREE.VertexColors });
	particles = new THREE.Points(geometry, material);
	scene.add(particles);
	//
	renderer = new THREE.WebGLRenderer({ antialias: false });
	renderer.setClearColor(scene.fog.color);
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight);
	container.appendChild(renderer.domElement);
	//
	stats = new Stats();
	container.appendChild(stats.dom);
	//
	//document.addEventListener('mousemove', onDocumentMouseMove, false);
	document.addEventListener( 'mousedown', onDocumentMouseDown);
	window.addEventListener('resize', onWindowResize, false);
}

function onDocumentMouseMove(event) {
	mouseX = event.clientX - windowHalfX;
	mouseY = event.clientY - windowHalfY;
}
function onDocumentMouseDown( event ) {
	event.preventDefault();
	var mouse3D = new THREE.Vector3(
			(event.clientX / window.innerWidth) * 2 - 1,
			-(event.clientY / window.innerHeight) * 2 + 1,
			0.5);
	var projector = new THREE.Projector();
	var raycaster = new THREE.Raycaster();
	raycaster.params.Points.threshold = 5;
	raycaster.setFromCamera(mouse3D, camera);
	var intersects = raycaster.intersectObject(particles);

	if (intersects.length == 0) return;
	console.log(intersects[0]);
	var idx = intersects[0].index;

	if (idx in selected) {
		var color = [255, 0, 0];
		delete selected[idx]
	} else {
		var color = [255, 255, 255];
		selected[idx] = true;
	}

	for (var i = 0; i < 3; i++) {
		colors[3*idx + i] = color[i];
	}

	geometry.attributes.color.needsUpdate = true;
}

function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
}
//
function animate() {
	requestAnimationFrame(animate);
	render();
	stats.update();
}

function render() {
	camera.position.x += ( mouseX - camera.position.x) * 0.05;
	camera.position.y += (-mouseY - camera.position.y) * 0.05;
	camera.lookAt(scene.position);
	renderer.render(scene, camera);
}
		</script>
	</body>
</html>
