<html>
	<head>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<div id="container"></div>
		<script src="model.js"></script>
		<script src="three/build/three.js"></script>
		<script src="three/js/controls/OrbitControls.js"></script>
		<script src="three/js/renderers/Projector.js"></script>
		<script src="three/js/libs/stats.min.js"></script>
		<script>
var container, stats;
var camera, scene, controls, renderer, particles, group, geometry, material, i, h, color, sprite, size;
var mouseX = 0, mouseY = 0;
var windowHalfX = window.innerWidth / 2;
var windowHalfY = window.innerHeight / 2;
var colors;
var positions;
var selected = {};
init();
animate();

function roundRect(ctx, x, y, w, h, r) 
{
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.lineTo(x+w-r, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+r);
    ctx.lineTo(x+w, y+h-r);
    ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
    ctx.lineTo(x+r, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-r);
    ctx.lineTo(x, y+r);
    ctx.quadraticCurveTo(x, y, x+r, y);
    ctx.closePath();
    ctx.fill();
	ctx.stroke();
}

// This place is not a place of honor.
// No highly esteemed deed is commemorated here.
// Nothing valued is here. What is here is repulsive to us. 
// It came from StackOverflow.
function textSprite(message, parameters) {
	if ( parameters === undefined ) parameters = {};
	var fontface = parameters.hasOwnProperty("fontface") ? parameters["fontface"] : "Arial";
	var fontsize = parameters.hasOwnProperty("fontsize") ? parameters["fontsize"] : 18;
	//fontsize *= 4;
	var borderThickness = parameters.hasOwnProperty("borderThickness") ? parameters["borderThickness"] : 4;
	var borderColor = parameters.hasOwnProperty("borderColor") ?parameters["borderColor"] : { r:0, g:0, b:0, a:1.0 };
	var backgroundColor = parameters.hasOwnProperty("backgroundColor") ?parameters["backgroundColor"] : { r:255, g:255, b:255, a:1.0 };
	var textColor = parameters.hasOwnProperty("textColor") ?parameters["textColor"] : { r:0, g:0, b:0, a:1.0 };

	var canvas = document.createElement('canvas');
	var context = canvas.getContext('2d');
	context.font = "Bold " + fontsize + "px " + fontface;
	var metrics = context.measureText( message );
	var textWidth = metrics.width;
	var width = (textWidth + borderThickness);
	var height = fontsize * 1.4 + borderThickness;

	canvas.width = width;
	canvas.height = height;
	context.font = "Bold " + fontsize + "px " + fontface;

	context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + "," + backgroundColor.b + "," + backgroundColor.a + ")";
	context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + "," + borderColor.b + "," + borderColor.a + ")";

	context.lineWidth = borderThickness;
	roundRect(context, borderThickness/2, borderThickness/2, width, height, 8);

	context.fillStyle = "rgba("+textColor.r+", "+textColor.g+", "+textColor.b+", 1.0)";
	context.fillText( message, borderThickness, fontsize + borderThickness);

	var texture = new THREE.Texture(canvas);
	texture.minFilter = THREE.LinearFilter; // NearestFilter;
	texture.needsUpdate = true;

	var spriteMaterial = new THREE.SpriteMaterial( { map: texture} );
	var sprite = new THREE.Sprite( spriteMaterial );
	sprite.scale.set(fontsize, fontsize / 2, 0.1 * fontsize);
	return sprite;
}
function init() {
	container = document.getElementById('container');
	//
	camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 2, 2000 );
	camera.position.z = 1000;

	scene = new THREE.Scene();
	//scene.fog = new THREE.FogExp2(0x000000, 0.0003);
	scene.fog = new THREE.Fog(0x000000, 750, 2000);
	//
	geometry = new THREE.BufferGeometry();

	positions = new Float32Array(900 * 3);
	colors = new Float32Array(900 * 3);
	var color = new THREE.Color();
	var strip_colors = [
		[  0,   1,   0],
		[0.5,   0,   1],
		[  1,   0,   0],
		[  1, 0.5,   0],
		[  1,   1,   0]
	]
	var i = 0;
	for (var s = 0; s < icosahedron_strips.length; s++) {
		for (var p = 0; p < icosahedron_strips[s].length; p++) {
			for (var j = 0; j < 3; j++) {
				positions[3*i + j] = icosahedron_strips[s][p][j];
				colors[3*i+j] = strip_colors[s][j];
			}
			i++;
		}
	}
	geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
	geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3).setDynamic(true));
	geometry.computeBoundingSphere();
	//
	var material = new THREE.PointsMaterial({ size: 10, vertexColors: THREE.VertexColors });
	particles = new THREE.Points(geometry, material);
	scene.add(particles);
	//
	renderer = new THREE.WebGLRenderer({ antialias: false });
	renderer.setClearColor(scene.fog.color);
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight);
	container.appendChild(renderer.domElement);

	controls = new THREE.OrbitControls(camera, renderer.domElement);
	controls.enableDamping = true;
	controls.dampingFactor = 0.75;
	controls.enableZoom = true;

	//
	stats = new Stats();
	container.appendChild(stats.dom);
	//
	document.addEventListener( "mousedown", onDocumentMouseDown);
	window.addEventListener('resize', onWindowResize, false);
}

function onDocumentMouseMove(event) {
	mouseX = event.clientX - windowHalfX;
	mouseY = event.clientY - windowHalfY;
}
function onDocumentMouseDown( event ) {
	var mouse3D = new THREE.Vector3(
			(event.clientX / window.innerWidth) * 2 - 1,
			-(event.clientY / window.innerHeight) * 2 + 1,
			0.5);
	var projector = new THREE.Projector();
	var raycaster = new THREE.Raycaster();
	raycaster.params.Points.threshold = 5;
	raycaster.setFromCamera(mouse3D, camera);
	var intersects = raycaster.intersectObject(particles);

	if (intersects.length == 0) return;
	console.log(intersects[0]);
	var idx = intersects[0].index;

	if (idx in selected) {
		var color = [0, 127, 127];
		sprite = selected[idx];
		scene.remove(sprite);
		delete selected[idx]
	} else {
		var color = [255, 255, 255];
		var text = textSprite("test", {
			fontface: 'courier new',
			fontsize: 36
		});
		text.position.set(intersects[0].point.x, intersects[0].point.y, intersects[0].point.z);
		scene.add(text);
		selected[idx] = text;
	}

	for (var i = 0; i < 3; i++) {
		colors[3*idx + i] = color[i];
	}

	geometry.attributes.color.needsUpdate = true;
}

function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
	controls.handleResize();
}
//
function animate() {
	requestAnimationFrame(animate);
	render();
	stats.update();
	controls.update();
}

function render() {
	renderer.render(scene, camera);
}
		</script>
	</body>
</html>
